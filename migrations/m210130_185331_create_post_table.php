<?php

use yii\db\Migration;

/**
 * Handles the creation of table `{{%post}}`.
 */
class m210130_185331_create_post_table extends Migration
{
    /**
     * {@inheritdoc}
     */
    public function safeUp()
    {
        $this->createTable('{{%post}}', [
            'id' => $this->primaryKey(),
            'user_id' => $this->integer(10)->notNull(),
            'title' => $this->string(255)->notNull(),
            'content' => $this->text()->notNull(),
            'incorrect' => $this->tinyInteger(4)->defaultValue(0),
        ]);

        $this->insert('post',[
            'user_id' =>1,
            'title' => 'А что значит "при правильной настройке"?',
            'content' => 'А что значит "при правильной настройке"?
             Есть размещение и ориентация антенн в пространстве,
              есть канал и мощность сигнала, чтобы не взаимодействовать
               с соседями. Какие микроту нужны особые настройки, учитывая что 
               у hap ac2 антенны вообще внутренние? У меня загород, вай-фай
                должен быть по всему участку, на данный момент я просто решил
                 вопрос, выставив одну антенну роутера через удлинитель на
                  крышу дома, десятилетний тыр-пыр-линк за $30 без "правильной 
                  настройки" (только мощность у него разблокировал и вкрутил 
                  посильнее) покрывает свои задачи без проблем, но ради IKEv2/IPSe
                  c приходится всё время держать включённым старый Атомный ноут на Винде.
                   Если вы имеете опыт с микротиками, не посоветуете что-то более старое и 
                   проверенное с внешними антеннами, без ненужного мне 5 ГГц, но с поддержкой MOS4?',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>1,
            'title' => 'При правильной настройке у hAP',
            'content' => 'При правильной настройке у hAP ac2 радио отличное. Можно также из недогих решений хоть для дома, хоть для малого офиса поставить на вход шлюз микрот RB760iGS (hEX s) или RB750Gr3 (hEX) при отсутствии первого в наличии, и от него протянуть провод на любую AP, какую заблагорассудится (от hEX s можно запитать её по passive PoE), и в более правильное для радио местоположение.',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>1,
            'title' => 'Спасибо.',
            'content' => 'Статьи видел, по ним не очень понятно, что именно поддерживается. Они там упорно топят в site-to-site, а я хочу просто с условного телефона заходить домой и внутри уже смотреть в локальную сеть, умные лампочки и прочее дырявое RDP, чтобы никакая голая задница у меня из дома в интернет не светила. А у меня ещё PPPoE, и что-то то ли провайдер gre режет, то ли у меня руки кривые. В общем, видимо не попробовав, не узнать. Смотрел на предмет Микротика hAP ac2 – вот он может всё и немного больше (ну, MOS точнее), но у него от радио многие плюются.',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>1,
            'title' => 'Каким образом ограничить доступ',
            'content' => 'Каким образом ограничить доступ к некоторым методам? Допустим, у контроллера CommentsController к actionDelete() доступ дать только администратору? $deleteComments= $authManager->createPermission(\'deleteComments\'); $authManager->add($deleteComments); $authManager->addChild($admin, $deleteComments); А дальше в методе выполнять проверку: if (!\Yii::$app->user->can(\'deleteComments\')) { throw new ForbiddenHttpException(\'Access denied\'); } Или есть более лаконичное/верное решение?',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>1,
            'title' => 'Если я хочу',
            'content' => 'Если я хочу настраивать привилегии юзергруппы через интерфейс, как быть тогда? Идея в том, чтобы через веб интерфейс можно было создавать юзергруппы и для каждой группы через тот же веб-интефейс настраивать привилегии.',
            'incorrect' => 1
        ]);
        $this->insert('post',[
            'user_id' =>2,
            'title' => 'Да, достаточно удобно',
            'content' => 'Да, достаточно удобно использовать Rbac в поведениях. Только в выше описанный метод нужно внести поправку: class UserGroupRule extends Rule { public function execute($user, $item, $params) { if (!\Yii::$app->user->isGuest) { } return false; } }',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>2,
            'title' => 'Теперь в контроллере',
            'content' => 'Теперь в контроллере из метода behaviors можно убрать правило access А зачем его убирать? Попробуйте воспользоваться matchCallback, внутри которого проверять permission. Либо сделайте по одному правилу на каждый action, указывая в roles название соответствующего permission (фишка в том, что yii\filters\AccessRule проверяет roles посредством того же can).',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>2,
            'title' => 'Хранить в одном месте',
            'content' => 'Хранить в одном месте, но иерархию можно построить так, чтобы она не пересекалась с основной. Например, префиксируя всё именем модуля.',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>2,
            'title' => 'Александр, а RBAC',
            'content' => 'Александр, а RBAC можно использовать внутри модулей? Опишу подробнее. Есть ядро сайта со своим набором RBAC. Пусть там будут какие-то стандартные роли guest, user, admin. При помощи их он видит (например) только главную страницу. Теперь пишем модуль news. И внутри него предполагается свои роли (readerNews, writerNews, moderatorNews). Т.е. они должны «налету» через бизнес-правила присвоиться юзеру, если он попал в раздел новостей. Если есть модуль blog — то там другие роли. Тоже «налету». Они не зависят друг от друга и никогда не пересекаются. Так вот, можно ли «дополнять» роли? Можно ли их хранить в разных местах (внутри модуля). Или нужно все хранить в одном месте? Просто судя по коду PhpManager там предполагается хранение только в одном месте.',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>2,
            'title' => 'Вы делаете ровно',
            'content' => 'Вы делаете ровно то же, но при помощи поля в базе данных. Прописываете нечто в `group`. Можно в `defaultRoles` оставить `user` с базовым набором прав, а повышение привилегий делать через API RBAC.',
            'incorrect' => 1
        ]);
        $this->insert('post',[
            'user_id' =>3,
            'title' => 'Роли можно построить так',
            'content' => 'Роли можно построить так, чтобы роли верхнего уровня и были по сути группами.',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>3,
            'title' => 'Способ 2',
            'content' => 'Способ 2 — прописать beforeAction, чтобы не писать «if !\Yii::$app->user->can» в каждом методе: Удобнее всего реализовать это в фильтре по аналогии с AccessControl.',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>3,
            'title' => 'Порылись чутка',
            'content' => 'giga ii должен поддерживать ike2v. Поставили компонент ipsec, ndims 2.06, включили — в настройках ike2v есть. Как бы по умолчанию этого не было, но это все из коробки — галочками из веб-интерфейса ставится штатно. Судя по статье поддерживает ike куча моделей, но некоторые могут поддерживать только ike1',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>3,
            'title' => 'Внимание!',
            'content' => 'Внимание! Перед выполнением этой команды нужно удалить файлы app/rbac/items.php и app/rbac/rules.php чтобы избежать конфликтов слияния Можно в методе RbacController::actionInit после строчки $authManager = \Yii::$app->authManager; добавить $authManager->removeAll(); Это удалит все права, тогда никаких конфликтов не возникнет.',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>3,
            'title' => 'Согласен с Александром',
            'content' => 'Нет ничего страшного в добавлении роли каждому пользователю (помимо использования defaultRoles можно просто добавлять роль guest автоматически при регистрации каждому пользователю).',
            'incorrect' => 1
        ]);
        $this->insert('post',[
            'user_id' =>4,
            'title' => 'Но ведь в этом случае',
            'content' => 'Но ведь в этом случае придется добавлять роль каждому пользователю. Это удобно, если пользователь должен иметь несколько ролей из иерархии ролей, но в случае с определенным первичным набором ролей удобнее хранить единственную роль пользователя в таблице пользователей.',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>4,
            'title' => 'Хранение в базе',
            'content' => 'Хранение в базе поля group излишне если вот это не критично: Не использовать назначение роли юзеру по его ID — вместо этого использовать несколько предустановленных ролей (defaultRoles);',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>4,
            'title' => 'Александр',
            'content' => 'Т.е. они должны «налету» через бизнес-правила присвоиться юзеру, если он попал в раздел новостей. Если есть модуль blog — то там другие роли. Тоже «налету».',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>4,
            'title' => 'Они не зависят',
            'content' => 'Они не зависят друг от друга и никогда не пересекаются. Так вот, можно ли «дополнять» роли? Можно ли их хранить в разных местах (внутри модуля). Или нужно все хранить в одном месте? Просто судя по коду PhpManager там предполагается хранение только в одном месте.',
            'incorrect' => 0
        ]);
        $this->insert('post',[
            'user_id' =>4,
            'title' => 'Прописываете нечто',
            'content' => 'Прописываете нечто в `group`. Можно в `defaultRoles` оставить `user` с базовым набором прав, а повышение привилегий делать через API RBAC.',
            'incorrect' => 1
        ]);
    }

    /**
     * {@inheritdoc}
     */
    public function safeDown()
    {
        $this->dropTable('{{%post}}');
    }
}
